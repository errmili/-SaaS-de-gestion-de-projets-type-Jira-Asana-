package com.projectsaas.file.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.projectsaas.file.dto.FileDownloadResponse;
import com.projectsaas.file.dto.FileDto;
import com.projectsaas.file.dto.FileSearchRequest;
import com.projectsaas.file.dto.FileShareDto;
import com.projectsaas.file.dto.ShareFileRequest;
import com.projectsaas.file.dto.UploadFileRequest;
import com.projectsaas.file.entity.FileEntity;
import com.projectsaas.file.entity.FileShare;
import com.projectsaas.file.exception.FileNotFoundException;
import com.projectsaas.file.repository.FileRepository;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class FileService {

    private final FileRepository fileRepository;

    // TODO: Add StorageService dependency for actual file storage
    private final StorageService storageService;           // ← AJOUTÉ
    private final AuthIntegrationService authIntegrationService; // ← AJOUTÉ


    public FileDto uploadFile(MultipartFile file, UploadFileRequest request, String token) {
        log.info("Uploading file: {}", file.getOriginalFilename());

        // Validation basique du token (temporaire pour tests)
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token is required");
        }

        UUID tenantId = extractTenantIdFromToken(token);
        UUID uploadedBy = extractUserIdFromToken(token);

        // Validation basique du fichier (votre code existant + améliorations)
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("File cannot be empty");
        }

        // Validation de la taille (ajout simple)
        if (file.getSize() > 100 * 1024 * 1024) { // 100MB
            throw new IllegalArgumentException("File size exceeds maximum allowed (100MB)");
        }

        // Validation du nom de fichier (ajout simple)
        if (file.getOriginalFilename() == null || file.getOriginalFilename().trim().isEmpty()) {
            throw new IllegalArgumentException("Filename is required");
        }

        // Check for duplicates if not allowed (votre code existant)
        if (!request.getAllowDuplicates()) {
            boolean exists = fileRepository.existsByOriginalNameAndTenantIdAndFolderIdAndStatus(
                    file.getOriginalFilename(), tenantId, request.getFolderId(), FileEntity.FileStatus.ACTIVE);
            if (exists) {
                throw new IllegalStateException("File with this name already exists in the folder");
            }
        }

        // Store file using StorageService (votre code existant)
        String storedName = generateStoredName(file.getOriginalFilename());

        // Version temporaire pour tests - sauvegarder localement
        String storedPath = saveFileLocally(file, storedName, tenantId);

        FileEntity fileEntity = FileEntity.builder()
                .id(UUID.randomUUID())
                .tenantId(tenantId)
                .originalName(file.getOriginalFilename())
                .storedName(storedName)
                .contentType(file.getContentType())
                .fileSize(file.getSize())
                .filePath(storedPath)
                .folderId(request.getFolderId())
                .entityType(parseEntityType(request.getEntityType()))
                .entityId(request.getEntityId())
                .uploadedBy(uploadedBy)
                .isPublic(request.getIsPublic())
                .uploadedAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .status(FileEntity.FileStatus.ACTIVE)
                .virusScanStatus(FileEntity.VirusScanStatus.CLEAN) // Temporaire pour tests
                .build();

        FileEntity savedFile = fileRepository.save(fileEntity);
        log.info("File uploaded successfully with ID: {}", savedFile.getId());

        return mapToDto(savedFile);
    }

    // Méthode temporaire pour sauvegarder localement (pour tests)
    private String saveFileLocally(MultipartFile file, String storedName, UUID tenantId) {
        try {
            // Créer le dossier s'il n'existe pas
            String baseDir = "./temp-storage/" + tenantId.toString();
            File directory = new File(baseDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }

            // Sauvegarder le fichier
            String filePath = baseDir + "/" + storedName;
            File destFile = new File(filePath);
            file.transferTo(destFile);

            log.info("File saved locally: {}", filePath);
            return filePath;

        } catch (Exception e) {
            log.error("Error saving file locally", e);
            throw new RuntimeException("Failed to save file: " + e.getMessage());
        }
    }

    @Transactional(readOnly = true)
    public FileDto getFileById(UUID fileId, String token) {
        log.info("Getting file by ID: {}", fileId);

        UUID tenantId = extractTenantIdFromToken(token);

        FileEntity file = fileRepository.findByIdAndTenantId(fileId, tenantId)
                .orElseThrow(() -> new FileNotFoundException("File not found: " + fileId));

        return mapToDto(file);
    }

    public FileDownloadResponse downloadFile(UUID fileId, String token) throws IOException {
        log.info("Downloading file: {}", fileId);

        UUID tenantId = extractTenantIdFromToken(token);

        FileEntity file = fileRepository.findByIdAndTenantId(fileId, tenantId)
                .orElseThrow(() -> new FileNotFoundException("File not found: " + fileId));

        // TODO: Get actual file stream from StorageService
        InputStream inputStream = getFileInputStream(file.getFilePath());

        return FileDownloadResponse.builder()
                .filename(file.getOriginalName())
                .contentType(file.getContentType())
                .fileSize(file.getFileSize())
                .inputStream(inputStream)
                .build();
    }

    @Transactional(readOnly = true)
    public Page<FileDto> getFiles(FileSearchRequest searchRequest, Pageable pageable, String token) {
        log.info("Getting files with search: {}", searchRequest.getSearch());

        UUID tenantId = extractTenantIdFromToken(token);
        FileEntity.FileStatus status = FileEntity.FileStatus.ACTIVE;

        Page<FileEntity> files;

        if (searchRequest.getSearch() != null && !searchRequest.getSearch().trim().isEmpty()) {
            files = fileRepository.searchFiles(searchRequest.getSearch(), tenantId, status, pageable);
        } else if (searchRequest.getFolderId() != null) {
            files = fileRepository.findByTenantIdAndFolderIdAndStatus(tenantId, searchRequest.getFolderId(), status, pageable);
        } else {
            files = fileRepository.findByTenantIdAndStatus(tenantId, status, pageable);
        }

        return files.map(this::mapToDto);
    }

    @Transactional(readOnly = true)
    public List<FileDto> getFolderFiles(UUID folderId, String token) {
        log.info("Getting files for folder: {}", folderId);

        UUID tenantId = extractTenantIdFromToken(token);
        FileEntity.FileStatus status = FileEntity.FileStatus.ACTIVE;

        List<FileEntity> files;
        if (folderId == null) {
            files = fileRepository.findByFolderIdIsNullAndTenantIdAndStatus(tenantId, status);
        } else {
            files = fileRepository.findByFolderIdAndTenantIdAndStatus(folderId, tenantId, status);
        }

        return files.stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    public void deleteFile(UUID fileId, String token) {
        log.info("Deleting file: {}", fileId);

        UUID tenantId = extractTenantIdFromToken(token);

        FileEntity file = fileRepository.findByIdAndTenantId(fileId, tenantId)
                .orElseThrow(() -> new FileNotFoundException("File not found: " + fileId));

        // Soft delete - change status instead of actual deletion
        file.setStatus(FileEntity.FileStatus.DELETED);
        file.setUpdatedAt(LocalDateTime.now());
        fileRepository.save(file);

        // TODO: Delete actual file from storage if needed

        log.info("File deleted successfully: {}", fileId);
    }

    @Transactional(readOnly = true)
    public List<FileDto> searchFiles(String query, String token) {
        log.info("Searching files with query: {}", query);

        UUID tenantId = extractTenantIdFromToken(token);
        FileEntity.FileStatus status = FileEntity.FileStatus.ACTIVE;

        List<FileEntity> files = fileRepository.searchFilesByName(query, tenantId, status);

        return files.stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    public FileShareDto shareFile(UUID fileId, ShareFileRequest request, String token) {
        log.info("Sharing file: {}", fileId);

        UUID tenantId = extractTenantIdFromToken(token);
        UUID sharedBy = extractUserIdFromToken(token);

        FileEntity file = fileRepository.findByIdAndTenantId(fileId, tenantId)
                .orElseThrow(() -> new FileNotFoundException("File not found: " + fileId));

        // Implémenter la logique de partage de fichier ici
        FileShareDto shareDto = FileShareDto.builder()
                .id(UUID.randomUUID())
                .fileId(fileId)
                .fileName(file.getOriginalName())
                .sharedBy(sharedBy)
                .shareToken(UUID.randomUUID().toString())
                .permission(FileShare.SharePermission.valueOf(request.getPermission().toString())) // Convertir SharePermission en String
                .createdAt(LocalDateTime.now())
                .expiresAt(request.getExpiresAt())
                .isActive(true)
                .accessCount(0)
                .isPublic(request.getSharedWith() == null) // Si sharedWith est null, partage public
                .isExpired(false)
                .build();

        log.info("File shared successfully: {}", fileId);
        return shareDto;
    }


    private FileDto mapToDto(FileEntity file) {
        // Calculer l'extension
        String extension = "";
        if (file.getOriginalName() != null && file.getOriginalName().contains(".")) {
            extension = file.getOriginalName().substring(file.getOriginalName().lastIndexOf("."));
        }

        // Déterminer le type de fichier
        String contentType = file.getContentType() != null ? file.getContentType().toLowerCase() : "";
        Boolean isImage = contentType.startsWith("image/");
        Boolean isVideo = contentType.startsWith("video/");
        Boolean isPdf = contentType.equals("application/pdf");

        return FileDto.builder()
                .id(file.getId())
                .originalName(file.getOriginalName())
                .storedName(file.getStoredName())
                .contentType(file.getContentType())
                .fileSize(file.getFileSize())
                .humanReadableSize(formatFileSize(file.getFileSize()))
                .status(file.getStatus())
                .uploadedBy(file.getUploadedBy())
                .uploadedAt(file.getUploadedAt())
                .updatedAt(file.getUpdatedAt())
                .entityType(file.getEntityType() != null ? file.getEntityType().toString() : null)
                .entityId(file.getEntityId())
                .isPublic(file.getIsPublic())
                .virusScanStatus(file.getVirusScanStatus())
                .extension(extension)
                .isImage(isImage)
                .isVideo(isVideo)
                .isPdf(isPdf)
                .folderId(file.getFolderId())
                .path(file.getFilePath())
                .width(null) // TODO: Récupérer les métadonnées d'image si disponibles
                .height(null) // TODO: Récupérer les métadonnées d'image si disponibles
                .duration(null) // TODO: Récupérer la durée vidéo si disponible
                .checksum(file.getChecksum())
                .thumbnailSmall(null) // TODO: Générer ou récupérer les miniatures
                .thumbnailMedium(null) // TODO: Générer ou récupérer les miniatures
                .thumbnailLarge(null) // TODO: Générer ou récupérer les miniatures
                .build();
    }

    // Méthode utilitaire pour formater la taille de fichier
    private String formatFileSize(Long bytes) {
        if (bytes == null || bytes == 0) return "0 B";

        String[] units = {"B", "KB", "MB", "GB", "TB"};
        int unitIndex = 0;
        double size = bytes.doubleValue();

        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }

        return String.format("%.1f %s", size, units[unitIndex]);
    }

    private UUID extractTenantIdFromToken(String token) {
        return authIntegrationService.extractTenantId(token);
    }

    private UUID extractUserIdFromToken(String token) {
        return authIntegrationService.extractUserId(token);
    }

    private String generateStoredName(String originalName) {
        String extension = "";
        int dotIndex = originalName.lastIndexOf('.');
        if (dotIndex > 0) {
            extension = originalName.substring(dotIndex);
        }
        return UUID.randomUUID().toString() + extension;
    }

    private InputStream getFileInputStream(String path) throws IOException {
        return storageService.retrieveFile(path);
    }
    private FileEntity.EntityType parseEntityType(String entityType) {
        if (entityType == null) return null;
        try {
            return FileEntity.EntityType.valueOf(entityType.toUpperCase());
        } catch (IllegalArgumentException e) {
            return FileEntity.EntityType.OTHER;
        }
    }

    private FileShare.SharePermission parseSharePermission(String accessLevel) {
        if (accessLevel == null) return FileShare.SharePermission.READ; // Correction ici, en minuscule
        try {
            switch (accessLevel.toUpperCase()) {
                case "VIEW":
                case "READ":
                    return FileShare.SharePermission.READ;
                case "DOWNLOAD":
                    return FileShare.SharePermission.DOWNLOAD;
                case "WRITE":
                case "EDIT":
                    return FileShare.SharePermission.WRITE;
                default:
                    return FileShare.SharePermission.READ; // Par défaut, on retourne READ
            }
        } catch (IllegalArgumentException e) {
            return FileShare.SharePermission.READ;
        }
    }

}