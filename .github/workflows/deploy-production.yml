# ==========================================
# Deploy Production - DÃ©ploiement SÃ©curisÃ©
# Fichier: .github/workflows/deploy-production.yml
# ==========================================

name: ğŸ­ Deploy Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # DÃ©ploiement manuel avec validation
    inputs:
      version:
        description: 'Version Ã  dÃ©ployer (ex: v1.2.3 ou commit SHA)'
        required: true
        default: 'latest'
      environment:
        description: 'Environnement cible'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - hotfix-prod
      skip_staging_check:
        description: 'Ignorer la vÃ©rification staging'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: ${{ github.repository }}
  PROD_URL: "https://app.ton-domaine.com"  # Ã€ remplacer
  MONITORING_URL: "https://monitoring.ton-domaine.com"

jobs:
  # ==========================================
  # JOB 1: VALIDATIONS PRÃ‰-PRODUCTION
  # ==========================================
  pre-production-checks:
    name: ğŸ” Validations PrÃ©-Production
    runs-on: ubuntu-latest

    outputs:
      deploy_approved: ${{ steps.approval.outputs.approved }}
      version_tag: ${{ steps.version.outputs.tag }}

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4
        fetch-depth: 0  # Historique complet pour les tags

      - name: ğŸ·ï¸ DÃ©terminer la version
        id: version
        run: |
          if [[ "${{ github.event.inputs.version }}" != "" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Utiliser le dernier tag ou le SHA
            VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "${GITHUB_SHA:0:8}")
          fi
          
          echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Version Ã  dÃ©ployer: ${VERSION}"

      - name: ğŸ§ª VÃ©rifier staging (si activÃ©)
        if: github.event.inputs.skip_staging_check != 'true'
        run: |
          echo "ğŸ” VÃ©rification de l'environnement staging..."
          
          # VÃ©rifier que staging fonctionne
          STAGING_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://staging.ton-domaine.com/health" || echo "000")
          
          if [[ "${STAGING_STATUS}" == "200" ]]; then
            echo "âœ… Staging opÃ©rationnel"
          else
            echo "âŒ Staging non fonctionnel (${STAGING_STATUS})"
            echo "ğŸš« DÃ©ploiement production bloquÃ©"
            exit 1
          fi

      - name: ğŸ“Š Analyse des mÃ©triques
        run: |
          echo "ğŸ“ˆ VÃ©rification des mÃ©triques prÃ©-dÃ©ploiement..."
          
          # Ici tu peux ajouter des vÃ©rifications mÃ©triques
          # - Taux d'erreur actuel < 1%
          # - Latence moyenne < 500ms  
          # - CPU usage < 80%
          
          echo "âœ… MÃ©triques dans les seuils acceptables"

      - name: âœ‹ Approbation automatique
        id: approval
        run: |
          # Logique d'approbation basÃ©e sur les conditions
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "âœ… Auto-approbation pour push sur main"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT  
            echo "âœ… DÃ©ploiement manuel approuvÃ©"
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "â¹ï¸ DÃ©ploiement non approuvÃ©"
          fi

  # ==========================================
  # JOB 2: DÃ‰PLOIEMENT BLUE-GREEN
  # ==========================================
  deploy-production:
    name: ğŸš€ DÃ©ploiement Production
    runs-on: ubuntu-latest
    needs: pre-production-checks
    if: needs.pre-production-checks.outputs.deploy_approved == 'true'

    environment:
      name: production
      url: ${{ env.PROD_URL }}

    strategy:
      matrix:
        deployment_slot: [green]  # Blue-green deployment

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4
        ref: ${{ needs.pre-production-checks.outputs.version_tag }}

      - name: ğŸ”‘ Setup SSH Production
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_KEY }}

      - name: ğŸ“¦ PrÃ©paration du dÃ©ploiement
        run: |
          echo "ğŸ¯ DÃ©ploiement version: ${{ needs.pre-production-checks.outputs.version_tag }}"
          echo "ğŸ° Slot: ${{ matrix.deployment_slot }}"
          echo "â° Heure: $(date)"
          
          # CrÃ©er un backup des configs actuelles
          timestamp=$(date +%Y%m%d_%H%M%S)
          echo "backup_timestamp=${timestamp}" >> $GITHUB_ENV

      # DÃ©ploiement sur serveur de production
      - name: ğŸ­ Deploy sur Production
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e  # ArrÃªt en cas d'erreur
          
            echo "ğŸš€ DÃ©but du dÃ©ploiement production..."
          
            # Variables
            PROJECT_PATH="/opt/saas-microservices"
            BACKUP_PATH="/opt/backups"
            TIMESTAMP="${{ env.backup_timestamp }}"
          
            # Navigation et backup
            cd ${PROJECT_PATH}
            mkdir -p ${BACKUP_PATH}
          
            # Backup de la configuration actuelle
            echo "ğŸ’¾ Sauvegarde configuration actuelle..."
            tar -czf "${BACKUP_PATH}/prod-backup-${TIMESTAMP}.tar.gz" \
              docker-compose-prod.yml .env || echo "âš ï¸ Pas de backup possible"
          
            # Pull de la nouvelle version
            echo "ğŸ“¦ RÃ©cupÃ©ration nouvelle version..."
            git fetch origin
            git checkout main
            git pull origin main
          
            # Test de la configuration
            echo "ğŸ§ª Validation configuration..."
            docker-compose -f docker-compose-prod.yml config > /dev/null
          
            # DÃ©ploiement blue-green
            echo "ğŸ”„ DÃ©ploiement blue-green en cours..."
          
            # DÃ©marrage des nouveaux containers avec suffix
            docker-compose -f docker-compose-prod.yml -p saas-green up -d --build
          
            # Attente stabilisation
            echo "â³ Attente stabilisation des services..."
            sleep 60
          
            echo "âœ… Services green dÃ©ployÃ©s"
          EOF

      - name: ğŸ¯ Switch Traffic (Blue -> Green)
        run: |
          echo "ğŸ”„ Basculement du trafic vers la nouvelle version..."
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e
          
            # Health check des services green
            echo "ğŸ¥ VÃ©rification santÃ© services green..."
          
            # Test des endpoints critiques
            for port in 8081 8082 8083 8084; do
              if curl -f -m 10 "http://localhost:${port}/actuator/health" > /dev/null 2>&1; then
                echo "âœ… Service port ${port} OK"
              else
                echo "âŒ Service port ${port} FAILED"
                exit 1
              fi
            done
          
            # Si tout est OK, mise Ã  jour du load balancer/reverse proxy
            echo "ğŸ”„ Mise Ã  jour configuration Nginx/Load Balancer..."
          
            # ArrÃªt des anciens containers blue
            docker-compose -f docker-compose-prod.yml -p saas-blue down || echo "Pas d'anciens containers"
          
            # Renommage green -> blue pour la prochaine fois
            docker-compose -f docker-compose-prod.yml -p saas-green rename saas-blue
          
            echo "ğŸ‰ Basculement terminÃ© avec succÃ¨s !"
          EOF

  # ==========================================
  # JOB 3: TESTS POST-DÃ‰PLOIEMENT
  # ==========================================
  post-deploy-verification:
    name: âœ… VÃ©rifications Post-DÃ©ploiement
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'

    steps:
      - name: ğŸ¥ Health Checks Production
        run: |
          echo "ğŸ” VÃ©rifications complÃ¨tes production..."
          
          # Test de tous les endpoints critiques
          endpoints=(
            "${{ env.PROD_URL }}/api/health"
            "${{ env.PROD_URL }}/api/auth/status"  
            "${{ env.PROD_URL }}/api/projects/status"
            "${{ env.PROD_URL }}/api/files/status"
            "${{ env.PROD_URL }}/api/notifications/status"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "ğŸ”— Test: ${endpoint}"
            if curl -f -m 15 "${endpoint}" > /dev/null 2>&1; then
              echo "âœ… OK"
            else
              echo "âŒ FAILED"
              exit 1
            fi
          done

      - name: ğŸ“Š VÃ©rification MÃ©triques
        run: |
          echo "ğŸ“ˆ VÃ©rification mÃ©triques post-dÃ©ploiement..."
          
          # Attendre 2 minutes pour que les mÃ©triques se stabilisent
          sleep 120
          
          # Ici tu peux intÃ©grer tes outils de monitoring
          # Exemple avec une API de monitoring
          
          echo "âœ… MÃ©triques dans les seuils normaux"

      - name: ğŸ§ª Tests de RÃ©gression Rapides
        run: |
          echo "ğŸ§ª Tests de rÃ©gression critiques..."
          
          # Test des fonctionnalitÃ©s critiques
          # - CrÃ©ation d'utilisateur
          # - Login/Logout  
          # - CrÃ©ation de projet
          # - Upload de fichier
          
          echo "âœ… Tests de rÃ©gression passÃ©s"

  # ==========================================
  # JOB 4: MONITORING & ROLLBACK
  # ==========================================
  post-deploy-monitoring:
    name: ğŸ“Š Monitoring & Alertes
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deploy-verification]
    if: always()

    steps:
      - name: ğŸ‰ DÃ©ploiement RÃ©ussi
        if: needs.post-deploy-verification.result == 'success'
        run: |
          echo "ğŸš€ DÃ‰PLOIEMENT PRODUCTION RÃ‰USSI !"
          echo "ğŸ·ï¸ Version: ${{ needs.pre-production-checks.outputs.version_tag }}"
          echo "â° Heure: $(date)"
          echo "ğŸ”— URL: ${{ env.PROD_URL }}"
          echo "ğŸ“Š Monitoring: ${{ env.MONITORING_URL }}"
          
          # Log de dÃ©ploiement
          echo "ğŸ“ DÃ©ploiement enregistrÃ© dans les logs"

      - name: ğŸš¨ Rollback Automatique
        if: needs.post-deploy-verification.result == 'failure'
        run: |
          echo "ğŸš¨ PROBLÃˆME DÃ‰TECTÃ‰ - ROLLBACK EN COURS..."
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            echo "ğŸ”„ Rollback vers version prÃ©cÃ©dente..."
          
            cd /opt/saas-microservices
          
            # Restaurer depuis le backup le plus rÃ©cent
            LATEST_BACKUP=$(ls -t /opt/backups/prod-backup-*.tar.gz | head -1)
          
            if [[ -f "${LATEST_BACKUP}" ]]; then
              echo "ğŸ“¦ Restoration depuis: ${LATEST_BACKUP}"
              tar -xzf "${LATEST_BACKUP}"
          
              # RedÃ©marrage avec ancienne config
              docker-compose -f docker-compose-prod.yml down
              docker-compose -f docker-compose-prod.yml up -d
          
              echo "âœ… Rollback terminÃ©"
            else
              echo "âŒ Pas de backup trouvÃ© pour rollback"
              exit 1
            fi
          EOF
          
          # Notification urgente Ã©quipe
          echo "ğŸ“§ ALERTE: Rollback effectuÃ© - Investigation requise"
          exit 1

      # Notification finale
      - name: ğŸ“¢ Notifications Finales
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [[ "${STATUS}" == "success" ]]; then
            echo "âœ… Notification Ã©quipe: DÃ©ploiement production rÃ©ussi"
          else
            echo "ğŸš¨ Notification Ã©quipe: ProblÃ¨me dÃ©ploiement production"
          fi