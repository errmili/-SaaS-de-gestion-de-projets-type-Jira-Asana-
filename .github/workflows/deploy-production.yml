# ==========================================
# Deploy Production - Déploiement Sécurisé
# Fichier: .github/workflows/deploy-production.yml
# ==========================================

name: 🏭 Deploy Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Déploiement manuel avec validation
    inputs:
      version:
        description: 'Version à déployer (ex: v1.2.3 ou commit SHA)'
        required: true
        default: 'latest'
      environment:
        description: 'Environnement cible'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - hotfix-prod
      skip_staging_check:
        description: 'Ignorer la vérification staging'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: ${{ github.repository }}
  PROD_URL: "https://app.ton-domaine.com"  # À remplacer
  MONITORING_URL: "https://monitoring.ton-domaine.com"

jobs:
  # ==========================================
  # JOB 1: VALIDATIONS PRÉ-PRODUCTION
  # ==========================================
  pre-production-checks:
    name: 🔍 Validations Pré-Production
    runs-on: ubuntu-latest

    outputs:
      deploy_approved: ${{ steps.approval.outputs.approved }}
      version_tag: ${{ steps.version.outputs.tag }}

    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4
        fetch-depth: 0  # Historique complet pour les tags

      - name: 🏷️ Déterminer la version
        id: version
        run: |
          if [[ "${{ github.event.inputs.version }}" != "" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Utiliser le dernier tag ou le SHA
            VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "${GITHUB_SHA:0:8}")
          fi
          
          echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          echo "🏷️ Version à déployer: ${VERSION}"

      - name: 🧪 Vérifier staging (si activé)
        if: github.event.inputs.skip_staging_check != 'true'
        run: |
          echo "🔍 Vérification de l'environnement staging..."
          
          # Vérifier que staging fonctionne
          STAGING_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://staging.ton-domaine.com/health" || echo "000")
          
          if [[ "${STAGING_STATUS}" == "200" ]]; then
            echo "✅ Staging opérationnel"
          else
            echo "❌ Staging non fonctionnel (${STAGING_STATUS})"
            echo "🚫 Déploiement production bloqué"
            exit 1
          fi

      - name: 📊 Analyse des métriques
        run: |
          echo "📈 Vérification des métriques pré-déploiement..."
          
          # Ici tu peux ajouter des vérifications métriques
          # - Taux d'erreur actuel < 1%
          # - Latence moyenne < 500ms  
          # - CPU usage < 80%
          
          echo "✅ Métriques dans les seuils acceptables"

      - name: ✋ Approbation automatique
        id: approval
        run: |
          # Logique d'approbation basée sur les conditions
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "✅ Auto-approbation pour push sur main"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT  
            echo "✅ Déploiement manuel approuvé"
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "⏹️ Déploiement non approuvé"
          fi

  # ==========================================
  # JOB 2: DÉPLOIEMENT BLUE-GREEN
  # ==========================================
  deploy-production:
    name: 🚀 Déploiement Production
    runs-on: ubuntu-latest
    needs: pre-production-checks
    if: needs.pre-production-checks.outputs.deploy_approved == 'true'

    environment:
      name: production
      url: ${{ env.PROD_URL }}

    strategy:
      matrix:
        deployment_slot: [green]  # Blue-green deployment

    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4
        ref: ${{ needs.pre-production-checks.outputs.version_tag }}

      - name: 🔑 Setup SSH Production
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_KEY }}

      - name: 📦 Préparation du déploiement
        run: |
          echo "🎯 Déploiement version: ${{ needs.pre-production-checks.outputs.version_tag }}"
          echo "🎰 Slot: ${{ matrix.deployment_slot }}"
          echo "⏰ Heure: $(date)"
          
          # Créer un backup des configs actuelles
          timestamp=$(date +%Y%m%d_%H%M%S)
          echo "backup_timestamp=${timestamp}" >> $GITHUB_ENV

      # Déploiement sur serveur de production
      - name: 🏭 Deploy sur Production
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e  # Arrêt en cas d'erreur
          
            echo "🚀 Début du déploiement production..."
          
            # Variables
            PROJECT_PATH="/opt/saas-microservices"
            BACKUP_PATH="/opt/backups"
            TIMESTAMP="${{ env.backup_timestamp }}"
          
            # Navigation et backup
            cd ${PROJECT_PATH}
            mkdir -p ${BACKUP_PATH}
          
            # Backup de la configuration actuelle
            echo "💾 Sauvegarde configuration actuelle..."
            tar -czf "${BACKUP_PATH}/prod-backup-${TIMESTAMP}.tar.gz" \
              docker-compose-prod.yml .env || echo "⚠️ Pas de backup possible"
          
            # Pull de la nouvelle version
            echo "📦 Récupération nouvelle version..."
            git fetch origin
            git checkout main
            git pull origin main
          
            # Test de la configuration
            echo "🧪 Validation configuration..."
            docker-compose -f docker-compose-prod.yml config > /dev/null
          
            # Déploiement blue-green
            echo "🔄 Déploiement blue-green en cours..."
          
            # Démarrage des nouveaux containers avec suffix
            docker-compose -f docker-compose-prod.yml -p saas-green up -d --build
          
            # Attente stabilisation
            echo "⏳ Attente stabilisation des services..."
            sleep 60
          
            echo "✅ Services green déployés"
          EOF

      - name: 🎯 Switch Traffic (Blue -> Green)
        run: |
          echo "🔄 Basculement du trafic vers la nouvelle version..."
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e
          
            # Health check des services green
            echo "🏥 Vérification santé services green..."
          
            # Test des endpoints critiques
            for port in 8081 8082 8083 8084; do
              if curl -f -m 10 "http://localhost:${port}/actuator/health" > /dev/null 2>&1; then
                echo "✅ Service port ${port} OK"
              else
                echo "❌ Service port ${port} FAILED"
                exit 1
              fi
            done
          
            # Si tout est OK, mise à jour du load balancer/reverse proxy
            echo "🔄 Mise à jour configuration Nginx/Load Balancer..."
          
            # Arrêt des anciens containers blue
            docker-compose -f docker-compose-prod.yml -p saas-blue down || echo "Pas d'anciens containers"
          
            # Renommage green -> blue pour la prochaine fois
            docker-compose -f docker-compose-prod.yml -p saas-green rename saas-blue
          
            echo "🎉 Basculement terminé avec succès !"
          EOF

  # ==========================================
  # JOB 3: TESTS POST-DÉPLOIEMENT
  # ==========================================
  post-deploy-verification:
    name: ✅ Vérifications Post-Déploiement
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'

    steps:
      - name: 🏥 Health Checks Production
        run: |
          echo "🔍 Vérifications complètes production..."
          
          # Test de tous les endpoints critiques
          endpoints=(
            "${{ env.PROD_URL }}/api/health"
            "${{ env.PROD_URL }}/api/auth/status"  
            "${{ env.PROD_URL }}/api/projects/status"
            "${{ env.PROD_URL }}/api/files/status"
            "${{ env.PROD_URL }}/api/notifications/status"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "🔗 Test: ${endpoint}"
            if curl -f -m 15 "${endpoint}" > /dev/null 2>&1; then
              echo "✅ OK"
            else
              echo "❌ FAILED"
              exit 1
            fi
          done

      - name: 📊 Vérification Métriques
        run: |
          echo "📈 Vérification métriques post-déploiement..."
          
          # Attendre 2 minutes pour que les métriques se stabilisent
          sleep 120
          
          # Ici tu peux intégrer tes outils de monitoring
          # Exemple avec une API de monitoring
          
          echo "✅ Métriques dans les seuils normaux"

      - name: 🧪 Tests de Régression Rapides
        run: |
          echo "🧪 Tests de régression critiques..."
          
          # Test des fonctionnalités critiques
          # - Création d'utilisateur
          # - Login/Logout  
          # - Création de projet
          # - Upload de fichier
          
          echo "✅ Tests de régression passés"

  # ==========================================
  # JOB 4: MONITORING & ROLLBACK
  # ==========================================
  post-deploy-monitoring:
    name: 📊 Monitoring & Alertes
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deploy-verification]
    if: always()

    steps:
      - name: 🎉 Déploiement Réussi
        if: needs.post-deploy-verification.result == 'success'
        run: |
          echo "🚀 DÉPLOIEMENT PRODUCTION RÉUSSI !"
          echo "🏷️ Version: ${{ needs.pre-production-checks.outputs.version_tag }}"
          echo "⏰ Heure: $(date)"
          echo "🔗 URL: ${{ env.PROD_URL }}"
          echo "📊 Monitoring: ${{ env.MONITORING_URL }}"
          
          # Log de déploiement
          echo "📝 Déploiement enregistré dans les logs"

      - name: 🚨 Rollback Automatique
        if: needs.post-deploy-verification.result == 'failure'
        run: |
          echo "🚨 PROBLÈME DÉTECTÉ - ROLLBACK EN COURS..."
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            echo "🔄 Rollback vers version précédente..."
          
            cd /opt/saas-microservices
          
            # Restaurer depuis le backup le plus récent
            LATEST_BACKUP=$(ls -t /opt/backups/prod-backup-*.tar.gz | head -1)
          
            if [[ -f "${LATEST_BACKUP}" ]]; then
              echo "📦 Restoration depuis: ${LATEST_BACKUP}"
              tar -xzf "${LATEST_BACKUP}"
          
              # Redémarrage avec ancienne config
              docker-compose -f docker-compose-prod.yml down
              docker-compose -f docker-compose-prod.yml up -d
          
              echo "✅ Rollback terminé"
            else
              echo "❌ Pas de backup trouvé pour rollback"
              exit 1
            fi
          EOF
          
          # Notification urgente équipe
          echo "📧 ALERTE: Rollback effectué - Investigation requise"
          exit 1

      # Notification finale
      - name: 📢 Notifications Finales
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [[ "${STATUS}" == "success" ]]; then
            echo "✅ Notification équipe: Déploiement production réussi"
          else
            echo "🚨 Notification équipe: Problème déploiement production"
          fi