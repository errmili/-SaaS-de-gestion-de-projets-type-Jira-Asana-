# ==========================================
# Deploy Staging - Environnement de Test
# Fichier: .github/workflows/deploy-staging.yml
# ==========================================

name: ğŸ§ª Deploy Staging

on:
  push:
    branches: [ develop ]
  workflow_dispatch:  # DÃ©ploiement manuel
    inputs:
      force_deploy:
        description: 'Force le dÃ©ploiement mÃªme si les tests Ã©chouent'
        required: false
        default: 'false'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: ${{ github.repository }}
  STAGING_URL: "https://staging.ton-domaine.com"  # Ã€ remplacer par ton domaine

jobs:
  # ==========================================
  # JOB 1: VÃ‰RIFICATIONS PRÃ‰-DÃ‰PLOIEMENT
  # ==========================================
  pre-deploy:
    name: ğŸ” VÃ©rifications PrÃ©-DÃ©ploiement
    runs-on: ubuntu-latest

    outputs:
      should_deploy: ${{ steps.check.outputs.deploy }}
      commit_sha: ${{ steps.commit.outputs.sha }}

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4
        fetch-depth: 2  # Pour comparer avec le commit prÃ©cÃ©dent

      - name: ğŸ” VÃ©rifier les changements
        id: changes
        run: |
          # VÃ©rifier si des services ont changÃ©
          CHANGED_SERVICES=""
          for service in auth-service project-service file-service notification-service; do
            if git diff --name-only HEAD~1 HEAD | grep -q "^${service}/"; then
              CHANGED_SERVICES="${CHANGED_SERVICES} ${service}"
            fi
          done
          
          echo "changed_services=${CHANGED_SERVICES}" >> $GITHUB_OUTPUT
          echo "ğŸ”„ Services modifiÃ©s: ${CHANGED_SERVICES:-Aucun}"

      - name: ğŸ¯ DÃ©cision de dÃ©ploiement
        id: check
        run: |
          FORCE="${{ github.event.inputs.force_deploy }}"
          CHANGES="${{ steps.changes.outputs.changed_services }}"
          
          if [[ "${FORCE}" == "true" ]] || [[ -n "${CHANGES}" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… DÃ©ploiement autorisÃ©"
          else
            echo "deploy=false" >> $GITHUB_OUTPUT  
            echo "â­ï¸ Aucun changement dÃ©tectÃ©, dÃ©ploiement ignorÃ©"
          fi

      - name: ğŸ“ Info commit
        id: commit
        run: |
          echo "sha=${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT

  # ==========================================
  # JOB 2: DÃ‰PLOIEMENT STAGING
  # ==========================================
  deploy-staging:
    name: ğŸš€ DÃ©ploiement Staging
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should_deploy == 'true'

    environment:
      name: staging
      url: ${{ env.STAGING_URL }}

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Setup SSH pour serveur staging
        if: env.STAGING_SSH_KEY != ''
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      # Option 1: DÃ©ploiement sur VPS/VM
      - name: ğŸ–¥ï¸ Deploy sur VPS Staging
        if: env.STAGING_SSH_KEY != ''
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
            # Navigation vers le projet
            cd /opt/saas-microservices || exit 1
          
            # Pull derniÃ¨res modifications
            git pull origin develop
          
            # ArrÃªt des services actuels
            docker-compose -f docker-compose-staging.yml down
          
            # Nettoyage des images anciennes
            docker system prune -af
          
            # Rebuild et redÃ©marrage
            docker-compose -f docker-compose-staging.yml up -d --build
          
            # Attendre que les services soient prÃªts
            sleep 30
          
            echo "ğŸ‰ DÃ©ploiement staging terminÃ© !"
          EOF

      # Option 2: DÃ©ploiement Docker local (pour tests)
      - name: ğŸ³ Deploy Docker Local (tests)
        if: env.STAGING_SSH_KEY == ''
        run: |
          echo "ğŸ§ª Simulation dÃ©ploiement staging local"
          
          # CrÃ©er docker-compose-staging.yml
          cp docker-compose-test.yml docker-compose-staging.yml
          
          # Remplacer les variables pour staging
          sed -i 's/saas-.*-test/saas-\1-staging/g' docker-compose-staging.yml
          sed -i 's/:808/:909/g' docker-compose-staging.yml  # Ports diffÃ©rents
          
          # DÃ©marrage stack staging
          docker-compose -f docker-compose-staging.yml up -d --build
          
          echo "âœ… Stack staging dÃ©marrÃ©e localement"

  # ==========================================
  # JOB 3: TESTS DE SMOKE (VÃ‰RIFICATIONS RAPIDES)
  # ==========================================
  smoke-tests:
    name: ğŸ’¨ Tests de Smoke
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'

    steps:
      - name: ğŸ“¥ Checkout des tests
        uses: actions/checkout@v4

      - name: â±ï¸ Attendre dÃ©marrage des services
        run: |
          echo "â³ Attente du dÃ©marrage complet des services..."
          sleep 60

      - name: ğŸ¥ Health Check - Auth Service
        run: |
          echo "ğŸ” Test Auth Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9091/actuator/health" > /dev/null; then
              echo "âœ… Auth Service OK"
              break
            fi
            echo "â³ Tentative $i/30..."
            sleep 10
          done

      - name: ğŸ¥ Health Check - Project Service
        run: |
          echo "ğŸ“‹ Test Project Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9092/actuator/health" > /dev/null; then
              echo "âœ… Project Service OK"
              break
            fi
            echo "â³ Tentative $i/30..."
            sleep 10
          done

      - name: ğŸ¥ Health Check - File Service
        run: |
          echo "ğŸ“ Test File Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9093/actuator/health" > /dev/null; then
              echo "âœ… File Service OK"
              break
            fi
            echo "â³ Tentative $i/30..."
            sleep 10
          done

      - name: ğŸ¥ Health Check - Notification Service
        run: |
          echo "ğŸ“§ Test Notification Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9094/actuator/health" > /dev/null; then
              echo "âœ… Notification Service OK"
              break
            fi
            echo "â³ Tentative $i/30..."
            sleep 10
          done

      - name: ğŸ§ª Test API Endpoints
        run: |
          echo "ğŸ”— Test des endpoints critiques..."
          
          # Test endpoint de santÃ© global
          curl -s "http://localhost:9091/api/health" || echo "âš ï¸ Global health check failed"
          
          # Test authentification (endpoint public)
          curl -s "http://localhost:9091/api/auth/status" || echo "âš ï¸ Auth status failed"
          
          echo "âœ… Tests de smoke terminÃ©s"

  # ==========================================
  # JOB 4: NOTIFICATIONS & ROLLBACK
  # ==========================================
  post-deploy:
    name: ğŸ“¬ Post-DÃ©ploiement
    runs-on: ubuntu-latest
    needs: [deploy-staging, smoke-tests]
    if: always()

    steps:
      - name: ğŸ‰ SuccÃ¨s Staging
        if: needs.deploy-staging.result == 'success' && needs.smoke-tests.result == 'success'
        run: |
          echo "ğŸš€ STAGING DEPLOY RÃ‰USSI !"
          echo "ğŸŒŸ Version: ${{ needs.pre-deploy.outputs.commit_sha }}"
          echo "ğŸ”— URL: ${{ env.STAGING_URL }}"
          echo "âœ… Tous les tests de smoke passÃ©s"
          echo "ğŸ‘‰ PrÃªt pour validation manuelle et dÃ©ploiement production"

      - name: âš ï¸ Ã‰chec - Rollback automatique
        if: needs.smoke-tests.result == 'failure'
        run: |
          echo "âŒ Ã‰CHEC DU DÃ‰PLOIEMENT STAGING"
          echo "ğŸ”„ Rollback automatique en cours..."
          
          # Ici tu peux ajouter la logique de rollback
          # Par exemple: redÃ©marrer la version prÃ©cÃ©dente
          
          echo "ğŸ“§ Notification Ã©quipe dev nÃ©cessaire"
          exit 1

      # Option: Notification Slack/Discord (si configurÃ©)
      - name: ğŸ“¢ Notification Slack
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow