# ==========================================
# Deploy Staging - Environnement de Test
# Fichier: .github/workflows/deploy-staging.yml
# ==========================================

name: 🧪 Deploy Staging

on:
  push:
    branches: [ develop ]
  workflow_dispatch:  # Déploiement manuel
    inputs:
      force_deploy:
        description: 'Force le déploiement même si les tests échouent'
        required: false
        default: 'false'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: ${{ github.repository }}
  STAGING_URL: "https://staging.ton-domaine.com"  # À remplacer par ton domaine

jobs:
  # ==========================================
  # JOB 1: VÉRIFICATIONS PRÉ-DÉPLOIEMENT
  # ==========================================
  pre-deploy:
    name: 🔍 Vérifications Pré-Déploiement
    runs-on: ubuntu-latest

    outputs:
      should_deploy: ${{ steps.check.outputs.deploy }}
      commit_sha: ${{ steps.commit.outputs.sha }}

    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4
        fetch-depth: 2  # Pour comparer avec le commit précédent

      - name: 🔍 Vérifier les changements
        id: changes
        run: |
          # Vérifier si des services ont changé
          CHANGED_SERVICES=""
          for service in auth-service project-service file-service notification-service; do
            if git diff --name-only HEAD~1 HEAD | grep -q "^${service}/"; then
              CHANGED_SERVICES="${CHANGED_SERVICES} ${service}"
            fi
          done
          
          echo "changed_services=${CHANGED_SERVICES}" >> $GITHUB_OUTPUT
          echo "🔄 Services modifiés: ${CHANGED_SERVICES:-Aucun}"

      - name: 🎯 Décision de déploiement
        id: check
        run: |
          FORCE="${{ github.event.inputs.force_deploy }}"
          CHANGES="${{ steps.changes.outputs.changed_services }}"
          
          if [[ "${FORCE}" == "true" ]] || [[ -n "${CHANGES}" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "✅ Déploiement autorisé"
          else
            echo "deploy=false" >> $GITHUB_OUTPUT  
            echo "⏭️ Aucun changement détecté, déploiement ignoré"
          fi

      - name: 📝 Info commit
        id: commit
        run: |
          echo "sha=${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT

  # ==========================================
  # JOB 2: DÉPLOIEMENT STAGING
  # ==========================================
  deploy-staging:
    name: 🚀 Déploiement Staging
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should_deploy == 'true'

    environment:
      name: staging
      url: ${{ env.STAGING_URL }}

    steps:
      - name: 📥 Checkout du code
        uses: actions/checkout@v4

      - name: 🔑 Setup SSH pour serveur staging
        if: env.STAGING_SSH_KEY != ''
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      # Option 1: Déploiement sur VPS/VM
      - name: 🖥️ Deploy sur VPS Staging
        if: env.STAGING_SSH_KEY != ''
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
            # Navigation vers le projet
            cd /opt/saas-microservices || exit 1
          
            # Pull dernières modifications
            git pull origin develop
          
            # Arrêt des services actuels
            docker-compose -f docker-compose-staging.yml down
          
            # Nettoyage des images anciennes
            docker system prune -af
          
            # Rebuild et redémarrage
            docker-compose -f docker-compose-staging.yml up -d --build
          
            # Attendre que les services soient prêts
            sleep 30
          
            echo "🎉 Déploiement staging terminé !"
          EOF

      # Option 2: Déploiement Docker local (pour tests)
      - name: 🐳 Deploy Docker Local (tests)
        if: env.STAGING_SSH_KEY == ''
        run: |
          echo "🧪 Simulation déploiement staging local"
          
          # Créer docker-compose-staging.yml
          cp docker-compose-test.yml docker-compose-staging.yml
          
          # Remplacer les variables pour staging
          sed -i 's/saas-.*-test/saas-\1-staging/g' docker-compose-staging.yml
          sed -i 's/:808/:909/g' docker-compose-staging.yml  # Ports différents
          
          # Démarrage stack staging
          docker-compose -f docker-compose-staging.yml up -d --build
          
          echo "✅ Stack staging démarrée localement"

  # ==========================================
  # JOB 3: TESTS DE SMOKE (VÉRIFICATIONS RAPIDES)
  # ==========================================
  smoke-tests:
    name: 💨 Tests de Smoke
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'

    steps:
      - name: 📥 Checkout des tests
        uses: actions/checkout@v4

      - name: ⏱️ Attendre démarrage des services
        run: |
          echo "⏳ Attente du démarrage complet des services..."
          sleep 60

      - name: 🏥 Health Check - Auth Service
        run: |
          echo "🔐 Test Auth Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9091/actuator/health" > /dev/null; then
              echo "✅ Auth Service OK"
              break
            fi
            echo "⏳ Tentative $i/30..."
            sleep 10
          done

      - name: 🏥 Health Check - Project Service
        run: |
          echo "📋 Test Project Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9092/actuator/health" > /dev/null; then
              echo "✅ Project Service OK"
              break
            fi
            echo "⏳ Tentative $i/30..."
            sleep 10
          done

      - name: 🏥 Health Check - File Service
        run: |
          echo "📁 Test File Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9093/actuator/health" > /dev/null; then
              echo "✅ File Service OK"
              break
            fi
            echo "⏳ Tentative $i/30..."
            sleep 10
          done

      - name: 🏥 Health Check - Notification Service
        run: |
          echo "📧 Test Notification Service..."
          for i in {1..30}; do
            if curl -s -f "http://localhost:9094/actuator/health" > /dev/null; then
              echo "✅ Notification Service OK"
              break
            fi
            echo "⏳ Tentative $i/30..."
            sleep 10
          done

      - name: 🧪 Test API Endpoints
        run: |
          echo "🔗 Test des endpoints critiques..."
          
          # Test endpoint de santé global
          curl -s "http://localhost:9091/api/health" || echo "⚠️ Global health check failed"
          
          # Test authentification (endpoint public)
          curl -s "http://localhost:9091/api/auth/status" || echo "⚠️ Auth status failed"
          
          echo "✅ Tests de smoke terminés"

  # ==========================================
  # JOB 4: NOTIFICATIONS & ROLLBACK
  # ==========================================
  post-deploy:
    name: 📬 Post-Déploiement
    runs-on: ubuntu-latest
    needs: [deploy-staging, smoke-tests]
    if: always()

    steps:
      - name: 🎉 Succès Staging
        if: needs.deploy-staging.result == 'success' && needs.smoke-tests.result == 'success'
        run: |
          echo "🚀 STAGING DEPLOY RÉUSSI !"
          echo "🌟 Version: ${{ needs.pre-deploy.outputs.commit_sha }}"
          echo "🔗 URL: ${{ env.STAGING_URL }}"
          echo "✅ Tous les tests de smoke passés"
          echo "👉 Prêt pour validation manuelle et déploiement production"

      - name: ⚠️ Échec - Rollback automatique
        if: needs.smoke-tests.result == 'failure'
        run: |
          echo "❌ ÉCHEC DU DÉPLOIEMENT STAGING"
          echo "🔄 Rollback automatique en cours..."
          
          # Ici tu peux ajouter la logique de rollback
          # Par exemple: redémarrer la version précédente
          
          echo "📧 Notification équipe dev nécessaire"
          exit 1

      # Option: Notification Slack/Discord (si configuré)
      - name: 📢 Notification Slack
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow